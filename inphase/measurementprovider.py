from inphase import Measurement
from inphase import Experiment
from inphase import decodeBinary
from inphase import signals
from inphase.inphasectl import inphasectl

import time
import math
import serial
import select
import threading
import socket
import logging
import queue


class MeasurementProvider:

    def close(self):
        pass


class ConstantRateMeasurementProvider(MeasurementProvider):

    def __init__(self, measurements, output_rate=1, loop=True):
        self.measurements = measurements
        self.output_rate = output_rate
        self.loop = loop

        self.last_timestamp = time.time()
        self.last_index = 0

    def getMeasurements(self):
        # get current time
        t = time.time()

        # time since last call to this function
        delta = t - self.last_timestamp

        # number of measurements that need to be returned (have been generated since the last call)
        measurement_count = math.floor(delta * self.output_rate)

        # get measurements from list
        to_return = list()
        if self.loop:
            for i in range(measurement_count):
                self.last_index = (self.last_index + 1) % len(self.measurements)
                to_return.append(self.measurements[self.last_index])
        else:
            to_return = self.measurements[self.last_index:self.last_index + measurement_count]
            self.last_index += measurement_count

        # timestamp from this call is saved only when measurements were returned
        if measurement_count > 0:
            self.last_timestamp = t

        return to_return


class SerialMeasurementProvider(MeasurementProvider):

    def __init__(self, serial_port, baudrate=38400):
        self.serial_port = serial_port
        self.baudrate = baudrate
        self.remaining = bytes()
        self.clean = bytes()
        self.measurements = list()
        self.measurements_lock = threading.Lock()
        self.running = True
        self.logger = logging.getLogger(__name__)
        self.child_thread = threading.Thread(target=self.serial_thread)
        self.child_thread.start()

    def serial_thread(self):
        # serial_for_url() allows more fancy usage of this class
        with serial.serial_for_url(self.serial_port, self.baudrate, timeout=0) as self.ser:
            while self.running:
                avail_read, avail_write, avail_error = select.select([self.ser], [], [], 1)
                try:
                    ser_data = self.ser.read(1000)
                except serial.serialutil.SerialException:
                    self.logger.error("Serial Device unavailable")
                    self.running = False
                    continue

                measurements, self.remaining, clean = decodeBinary(self.remaining + ser_data)
                with self.measurements_lock:
                    self.measurements += measurements
                self.clean += clean

    def getMeasurements(self):
        with self.measurements_lock:
            measurements = self.measurements
            self.measurements = list()  # use a new list, to not return the last measurements again
        return measurements

    def close(self):
        self.running = False


class ModifiedMeasurementProvider(MeasurementProvider):
    """
    A MeasurementProvider that gets Measurements from any other provider, applies the specified modifiers
    and returns the result.
    """
    pass


class SawtoothMeasurementProvider(MeasurementProvider):
    """
    A MeasurementProvider that generates Measurements with calculated pmu samples based on the specified
    Distance.
    """

    def __init__(self, distance, count):
        self.count = count
        self.distance = distance
        self.frequency = signals.dist2slope(self.distance)

    def getMeasurements(self):
        m = {
            '_comment': 'Generated by %s' % (self.__class__.__name__),
            'initiator': {
                'antenna_offset': 0,
                'location': [0, 0, self.distance],
                'moving': False,
                'name': 'Dummy Node'
            },
            'real_distance': self.distance,
            'real_nlos': False,
            'reflector': {
                'antenna_offset': 0,
                'location': [0, 0, 0],
                'moving': False,
                'name': 'Dummy Node'
            },
            'samples': signals.generate_sawtooth_samples(frequency=self.frequency * 199)
        }
        measurements = [Measurement(m)] * self.count
        return measurements


class InphasectlMeasurementProvider(MeasurementProvider):
    """ A MeasurementProvider using inphasectl to setup node and get measurements on demand."""

    def __init__(self, serial_port=None, baudrate=38400, address=None, port=50000, count=3, target=None):
        self.count = count
        self.target = target
        self.remaining = bytes()
        self.measurements = list()
        self.measurements_lock = threading.Lock()
        self.measuring = False
        self.running = True
        self.logger = logging.getLogger(__name__)
        self.node = inphasectl()
        self.node.connect(serial_port, baudrate, address, port)
        if self.node.running:
            self.child_thread = threading.Thread(target=self.measurement_thread)
            self.child_thread.start()
            self.write_cfg(target=self.target, count=self.count)
        else:
            raise Exception("No connection to node")

    def write_cfg(self, target, count):
        """ Write settings to node and read back.

        Args:
            target (int, optional): Address of node to do measurements with.
            count (int,optional): Number of measurements to do.

        Raises:
            ValueError: If value on node does not match setted.
        """
        if target is None:
            target = self.target

        if count is None:
            count = self.count

        settings = dict()
        settings['distance_sensor0.target'] = target
        settings['distance_sensor0.count'] = count

        for parameter_to_set in settings:
            value_to_set = settings[parameter_to_set]
            if not self.node.set_param(parameter_to_set, value_to_set):
                raise ValueError("Setting parameter failed %s", parameter_to_set)

    def process_data_stream(self, data):
        """ Process read datastream and extract measurements from binary data

        Args:
            data (str): datastream to process

        Returns:
            measurements (list): List of measurements extracted
        """

        measurements, self.remaining, clean = decodeBinary(self.remaining + data)
        self.logger.debug("bindec -> remaining: {}".format(self.remaining))
        self.logger.debug("bindec -> len measurements: {}".format(len(measurements)))
        self.logger.debug("bindec -> clean: {}".format(clean))
        return measurements

    def measurement_thread(self):
        self.logger.info("start measurement_thread")
        while self.running:
            try:
                data_to_process = self.node.data_queue.get(timeout=0.5)
                self.logger.debug("new data_to_process len %d", len(data_to_process))
                self.measuring = True
                measurements = self.process_data_stream(data_to_process)
                self.node.data_queue.task_done()
                with self.measurements_lock:
                    self.measurements += measurements
            except queue.Empty:
                self.logger.debug("Timeout on waiting for data")
                if 'distance_sensor0.start' in self.node.read_parameters:
                    start = self.node.read_parameters['distance_sensor0.start']
                    self.logger.debug("start is %s", start)
                    if start == 0:
                        self.measuring = False

        self.logger.info("stop measurement_thread")

    def getMeasurements(self):
        self.logger.info("measurements start")
        self.node.start()
        self.measuring = True
        while self.measuring:
            self.logger.info("waiting measuring %s running %s" % (self.measuring, self.running))
            time.sleep(0.5)
        self.logger.info("measurements done")
        with self.measurements_lock:
            measurements = self.measurements
            self.measurements = list()  # use a new list, to not return the last measurements again
        self.logger.info("requested %d received %d", self.count, len(measurements))

        return measurements

    def close(self):
        self.logger.info("closing")
        self.running = False
        self.node.disconnect()


class BinaryFileMeasurementProvider(ConstantRateMeasurementProvider):

    def __init__(self, file_names, output_rate=1, loop=True):
        self.measurements = list()
        self.clean = bytes()
        if not isinstance(file_names, list):
            file_names = [file_names]
        for file_name in file_names:
            with open(file_name, 'rb') as f:
                m, r, c = decodeBinary(f.read())
            self.measurements += m
            self.clean += c

        super(BinaryFileMeasurementProvider, self).__init__(self.measurements, output_rate, loop)


class InPhaseBridgeMeasurementProvider(MeasurementProvider):

    def __init__(self, address, port=50000):
        self.address = address
        self.port = port
        self.remaining = bytes()
        self.clean = bytes()
        self.measurements = list()
        self.measurements_lock = threading.Lock()
        self.running = True
        self.child_thread = threading.Thread(target=self.socket_thread)
        self.child_thread.start()

    def socket_thread(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((self.address, self.port))
        while self.running:
            avail_read, avail_write, avail_error = select.select([self.sock], [], [], 1)
            sock_data = self.sock.recv(1000)
            measurements, self.remaining, clean = decodeBinary(self.remaining + sock_data)
            with self.measurements_lock:
                self.measurements += measurements
            self.clean += clean
        self.sock.close()

    def getMeasurements(self):
        with self.measurements_lock:
            measurements = self.measurements
            self.measurements = list()  # use a new list, to not return the last measurements again
        return measurements

    def close(self):
        self.running = False


class YAMLMeasurementProvider(MeasurementProvider):

    def __init__(self, experiment_file, realtime=True, output_rate=1, loop=True):
        self.realtime = realtime
        self.measurements = Experiment(experiment_file).measurements

        # if this should not run in real time, just use the constant rate provider...
        if not self.realtime:
            self.provider = ConstantRateMeasurementProvider(self.measurements, output_rate, loop)
            self.getMeasurements = self.provider.getMeasurements
        else:
            for m in self.measurements:
                if 'timestamp' not in m:
                    raise Exception('Measurements do not contain timestamps!')
            self.loop = loop
            self.last_index = -1
            self.time_offset = time.time() - self.measurements[0]['timestamp']
            self.last_timestamp = self.measurements[0]['timestamp']

    def getMeasurements(self):
        # get current system time and convert to measurement time
        current_time = time.time()
        measurement_time = current_time - self.time_offset

        to_return = list()

        i = self.last_index
        while True:
            i += 1
            if i >= len(self.measurements):
                if not self.loop:
                    # not looping, break here
                    break
                else:
                    # start over
                    i = 0
                    self.time_offset = current_time - self.measurements[0]['timestamp']
                    measurement_time = self.measurements[0]['timestamp']
            if self.measurements[i]['timestamp'] > measurement_time:
                break

            to_return += [self.measurements[i]]
            self.last_index = i

        self.last_timestamp = measurement_time
        return to_return
